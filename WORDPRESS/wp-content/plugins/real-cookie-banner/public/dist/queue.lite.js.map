{"version":3,"file":"queue.lite.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///external var \"devowlWp_utils\"","webpack:///external var \"devowlWp_realQueue\"","webpack:///./src/public/ts/types/queue.tsx","webpack:///./src/public/ts/utils/i18n.tsx","webpack:///external var \"jQuery\"","webpack:///./src/public/ts/wp-api/scannerQueue.post.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/utils/mapUrlToRootUrl.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/findByRobots.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/findByKnownFilenames.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/crawl.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/parse.tsx","webpack:///./src/public/ts/others/scanner/crawlSitemap.tsx","webpack:///../../isomorphic-packages/sitemap-crawler/src/find.tsx","webpack:///./src/public/ts/queue.tsx","webpack:///./src/public/ts/others/scanner/execute.tsx","webpack:///./src/public/ts/others/scanner/listenStatus.tsx","webpack:///./src/public/ts/others/scanner/automaticScanStarter.tsx"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = devowlWp_utils;","const __WEBPACK_NAMESPACE_OBJECT__ = devowlWp_realQueue;","const SCAN_QUEUE_JOB = \"rcb-scan\";\nconst AUTOMATIC_SCAN_STATER_QUEUE_JOB = \"rcb-automatic-scan-starter\";\nexport { SCAN_QUEUE_JOB, AUTOMATIC_SCAN_STATER_QUEUE_JOB };","/* istanbul ignore file: this file does not contain any logic, only factory calls */\nimport { createLocalizationFactory, BaseOptions } from \"@devowl-wp/utils\"; // Only needed once per `window`\n\nlet FACTORY_MEMO;\n\nfunction get() {\n  return FACTORY_MEMO ? FACTORY_MEMO : FACTORY_MEMO = createLocalizationFactory(BaseOptions.getPureSlug(process.env.slug));\n}\n\nconst _n = (...args) => get()._n(...args);\n\nconst _nx = (...args) => get()._nx(...args);\n\nconst _x = (...args) => get()._x(...args);\n\nconst __ = (...args) => get().__(...args);\n\nconst _i = (...args) => get()._i(...args);\n\nexport { _n, _nx, _x, __, _i };","const __WEBPACK_NAMESPACE_OBJECT__ = jQuery;","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestScannerQueuePost = {\n  path: \"/scanner/queue\",\n  method: RouteHttpVerb.POST\n};","/**\n * @see https://stackoverflow.com/a/6944961/5506547\n * @see https://regex101.com/r/wLTlSe/1\n */\nconst REGEXP_URL_PATH = /.+?:\\/\\/.+?(\\/.+?)(?:#|\\?(.*)|$)/;\n/**\n * Get path of (sitemap) URL as we do not rely on the received host.\n *\n * - site got cloned with WP Duplicator -> wrong host in robots.txt if not yet flushed\n * - General > Settings is configured with `http` but site is served with `https`\n */\n\nfunction mapUrlToRootUrl(rootUrl, receivedUrl, query = \"\") {\n  var _rootUrl$match;\n\n  const rootUrlPath = ((_rootUrl$match = rootUrl.match(REGEXP_URL_PATH)) === null || _rootUrl$match === void 0 ? void 0 : _rootUrl$match[1]) || \"/\";\n  const match = receivedUrl.match(REGEXP_URL_PATH);\n\n  if (match) {\n    const [, path, receivedQuery] = match; // e.g. `/sitemap.xml`, `my-param=1`\n\n    const useQuery = receivedQuery ? \"?\".concat(receivedQuery).concat(query ? \"?\".concat(query) : \"\") : query ? \"?\".concat(query) : \"\";\n    return \"\".concat(rootUrl).concat(path.substr(rootUrlPath.length)).concat(useQuery);\n  }\n\n  return false;\n}\n\nexport { mapUrlToRootUrl };","import { mapUrlToRootUrl } from \"./utils\";\nconst ROBOTS_TXT = \"robots.txt\";\n/**\n * Look for a valid `robots.txt` and parse `Sitemap` url.\n *\n * @see https://regex101.com/r/Trn97e/1\n * @param forceSitemapArgument Append this query argument to the `robots.txt` in case you can server-side activate the sitemap\n */\n\nasync function findByRobots(url, forceSitemapArgument) {\n  try {\n    const query = forceSitemapArgument ? \"\".concat(forceSitemapArgument, \"=1\") : \"\";\n    const response = await fetch(\"\".concat(url).concat(ROBOTS_TXT).concat(query ? \"?\".concat(query) : \"\"));\n\n    if (!response.ok) {\n      return false;\n    }\n\n    const content = await response.text();\n    const sitemapUrl = content.match(/^sitemap:(.*)$/im)[1].trim();\n    const correctedSitemapUrl = mapUrlToRootUrl(url, sitemapUrl, query);\n\n    if (correctedSitemapUrl) {\n      // Check if sitemap really exists and isn't stale (e.g. deactivate RankMath SEO WP plugin does not recreate robots.txt)\n      const responseCheckSitemap = await fetch(correctedSitemapUrl);\n\n      if (!responseCheckSitemap.ok) {\n        return false;\n      } // Scenario: Sitemap does not exist but a plugin redirects directly to the homepage => no error code\n\n\n      const body = await responseCheckSitemap.text();\n\n      if (!/<(?:sitemap|urlset)/gm.test(body)) {\n        return false;\n      }\n\n      return correctedSitemapUrl;\n    }\n\n    return false;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport { findByRobots };","const KNOWN_FILENAMES = [\"sitemap.xml\", \"sitemap_index.xml\", \"sitemap-index.xml\", \"sitemap/\", \"post-sitemap.xml\", \"sitemap/sitemap.xml\", \"sitemap/index.xml\", \"sitemapindex.xml\", \"sitemap.php\", \"sitemap.txt\", \"index.php/sitemap_index.xml\", \"index.php?xml_sitemap=params=\", \"glossar/sitemap.xml\"];\n/**\n * Look known sitemap URLs when it is not yet filled in the `robots.txt`.\n *\n * @see https://pagedart.com/blog/how-to-find-the-sitemap-of-a-website/#manually\n */\n\nasync function findByKnownFilenames(root, tryKnownFilenames = KNOWN_FILENAMES) {\n  const promises = tryKnownFilenames.map(filename => fetch(\"\".concat(root).concat(filename), {\n    // Do not throw an error for failed CORS requests, instead we expect an empty response\n    mode: \"no-cors\"\n  }));\n\n  for (const promise of promises) {\n    try {\n      const response = await promise;\n      const responseBody = await response.text(); // We do not rely on `fetch.ok` cause e.g. RankMath forces `404` error code even the sitemap is rendered\n\n      if (responseBody.indexOf(\"<sitemapindex\") > -1 || responseBody.indexOf(\"<urlset\") > -1) {\n        return response.url;\n      }\n    } catch (e) {// Silence is golden.\n    }\n  }\n\n  return false;\n}\n\nexport { findByKnownFilenames };","import { parse } from \".\";\nimport { mapUrlToRootUrl } from \"./utils\";\n/**\n * Use pseudo base so e.g. sitemaps configured as `/sitemap.xml` (relative) configured\n * in `robots.txt` are parsed correctly.\n */\n\nconst PSEUDO_URL_BASE = \"https://base\";\n\nasync function crawl(rootUrl, sitemapUrl, sites) {\n  if (!sites) {\n    // Initial crawl\n    try {\n      return (await crawl(rootUrl, sitemapUrl, [])).sort((a, b) => a.length - b.length);\n    } catch (e) {\n      // Atm we are ignoring errors\n      console.error(e);\n      return [];\n    }\n  } else {\n    try {\n      const document = await parse(sitemapUrl);\n      const {\n        protocol: sitemapProtocol\n      } = new URL(sitemapUrl, PSEUDO_URL_BASE); // Check if sitemap is an index of multiple sitemaps\n\n      const sitemapIndex = document.querySelector(\"sitemapindex\");\n\n      if (sitemapIndex) {\n        const indexUrls = Array.from(sitemapIndex.children).map(c => {\n          var _c$querySelector;\n\n          return (_c$querySelector = c.querySelector(\"loc\")) === null || _c$querySelector === void 0 ? void 0 : _c$querySelector.textContent;\n        }) // In some cases, the `DOMParser` can return `parsererror` children, we need to skip\n        // them as the other `sitemap` children are still correctly parsed\n        .filter(Boolean); // Iterate sequentially instead of concurrent as we are in a browser and we should avoid parallel requests here (CloudFlare Bots etc.)\n\n        for (const indexUrl of indexUrls) {\n          const useUrl = mapUrlToRootUrl(rootUrl, indexUrl) || indexUrl;\n          await crawl(rootUrl, useUrl, sites);\n        }\n      } // Check for URL set (we finally found an URL!)\n\n\n      const urlSet = document.querySelector(\"urlset\");\n\n      if (urlSet) {\n        const urls = Array.from(urlSet.children).map(c => {\n          var _c$querySelector2;\n\n          return (_c$querySelector2 = c.querySelector(\"loc\")) === null || _c$querySelector2 === void 0 ? void 0 : _c$querySelector2.textContent;\n        }).filter(Boolean).map(url => {\n          try {\n            const urlInstance = new URL(url, PSEUDO_URL_BASE);\n\n            if (urlInstance.protocol === \"http:\") {\n              urlInstance.protocol = sitemapProtocol;\n            }\n\n            return urlInstance.toString();\n          } catch (e) {\n            // Silence is golden.\n            return url;\n          }\n        }); // Not needed atm cause WordPress and plugins force the protocol correctly here\n        //.map((url) => mapUrlToRootUrl(rootUrl, url) || url);\n\n        sites.push(...urls);\n      }\n    } catch (e) {\n      console.error(\"Error occurred during \\\"crawl('\".concat(sitemapUrl, \"')\\\":\\n\\r Error: \").concat(e));\n    }\n  }\n\n  return sites;\n}\n\nexport { crawl };","async function parse(sitemapUrl) {\n  const response = await fetch(sitemapUrl);\n  const body = await response.text();\n  return new DOMParser().parseFromString(body.trim(), \"application/xml\");\n}\n\nexport { parse };","import { __ } from \"../../utils\";\nimport { crawl, findSitemap } from \"@devowl-wp/sitemap-crawler\";\n\nasync function crawlSitemap(setStep) {\n  const textOfferSupport = __('If you think a sitemap exists but you get this error, please <a href=\"%s\" target=\"_blank\" />contact our support</a> and we will look individually where the problem is in your WordPress installation.', __(\"https://devowl.io/support/\")); // Use original `home_url` to support WordPress installations within a subfolder (https://git.io/JRM9g)\n\n\n  let rootUrl = window.realCookieBannerQueue.originalHomeUrl;\n  rootUrl = rootUrl.split(\"?\", 2)[0];\n  setStep === null || setStep === void 0 ? void 0 : setStep(\"find-sitemap\");\n  const sitemapUrl = await findSitemap(rootUrl, \"rcb-force-sitemap\", [\"?sitemap=index&rcb-force-sitemap=1\"]);\n\n  if (sitemapUrl === false) {\n    throw new Error(\"\".concat(__(\"We didn't find a sitemap on your website. We need it to scan all the subpages of your website. Do you have this feature disabled in your WordPress?\"), \" \").concat(textOfferSupport));\n  }\n\n  setStep === null || setStep === void 0 ? void 0 : setStep(\"collect-sitemap\");\n  let sites = [];\n\n  try {\n    sites = await crawl(rootUrl, sitemapUrl);\n  } catch (e) {\n    throw new Error(\"\".concat(__(\"The sitemap could not be parsed. Therefore, we cannot check for services on your website.\"), \" \").concat(textOfferSupport));\n  }\n\n  if (sites.length === 0) {\n    throw new Error(\"\".concat(__(\"The sitemap is empty. So, we could not add any URLs to the scanner.\"), \" \").concat(textOfferSupport));\n  }\n\n  return sites;\n}\n\nexport { crawlSitemap };","import { findByRobots, findByKnownFilenames } from \".\";\n/**\n * Find sitemap URL by different methods.\n *\n * @param rootUrl The root URL of your current website (with leading `/`!)\n * @param forceSitemapArgument See `findByRobots`\n */\n\nfunction findSitemap(rootUrl, forceSitemapArgument, tryKnownFilenames) {\n  return new Promise((resolve, reject) => {\n    /**\n     * We need to wrap the resolving mechanism in an additional non-blocking `setTimeout`.\n     * Why? Requesting a lot of wrong URLs with `findByKnownFilenames` could lead to a race\n     * condition within browsers and their Race Cache With Network (RCWN).\n     *\n     * Without this, this could lead to wrong error messages when requesting the found sitemap URL\n     * again, e.g. with `crawl`.\n     */\n    const resolver = result => setTimeout(() => resolve(result), 100);\n\n    (async () => {\n      try {\n        // 1. `robots.txt`\n        const robotsTxt = await findByRobots(rootUrl);\n\n        if (robotsTxt) {\n          resolver(robotsTxt);\n          return;\n        } // 2. Known filenames\n\n\n        const byKnownFilenames = await findByKnownFilenames(rootUrl);\n\n        if (byKnownFilenames) {\n          resolver(byKnownFilenames);\n          return;\n        } // 3. Force and activate `robots.txt` and sitemaps in WordPress itself\n        // e.g. when the setting of visibility is activated in Settings > Reading\n        // 1. `robots.txt`\n\n\n        if (forceSitemapArgument) {\n          const robotsTxtForce = await findByRobots(rootUrl, forceSitemapArgument);\n\n          if (robotsTxtForce) {\n            resolver(robotsTxtForce);\n            return;\n          }\n        } // 4. Try another set of known filenames\n\n\n        if (tryKnownFilenames) {\n          const byKnownFilenamesCustom = await findByKnownFilenames(rootUrl, tryKnownFilenames);\n\n          if (byKnownFilenamesCustom) {\n            resolver(byKnownFilenamesCustom);\n            return;\n          }\n        }\n\n        resolver(false);\n      } catch (e) {\n        reject(e);\n      }\n    })();\n  });\n}\n\nexport { findSitemap };","/* istanbul ignore file: we do not need to care about the entry point file as errors are detected through integration tests (E2E) */\nimport { handleCorruptRestApi } from \"@devowl-wp/utils\";\nimport { listenScannerJobExecution, listenScannerStatus, listenAutomaticScanStarterJobExecution } from \"./others\";\n/**\n * The entry point for the `real-queue` workers\n */\n\nhandleCorruptRestApi({// We do not have checks for this REST API as it should be solved by real-cookie-banner itself\n});\nlistenScannerJobExecution();\nlistenScannerStatus();\nlistenAutomaticScanStarterJobExecution();","import { CLIENT_JOB_EVENT_PREFIX, JOB_DELAY_EVENT_PREFIX, fetchStatus } from \"@devowl-wp/real-queue\";\nimport { applyQueryString } from \"@devowl-wp/utils\";\nimport { SCAN_QUEUE_JOB } from \"../../types\";\n/**\n * Add listener for the scanner status and automatically update the UI.\n */\n\nfunction listenScannerJobExecution() {\n  document.addEventListener(\"\".concat(JOB_DELAY_EVENT_PREFIX).concat(SCAN_QUEUE_JOB), ({\n    detail: {\n      isIdle,\n      settings\n    }\n  }) => {\n    const isInScannerTab = /page=real-cookie-banner(?:-pro)?-component#\\/scanner/.test(window.location.href);\n    settings.delay_ms = isInScannerTab || isIdle ? settings.delay_ms : 3000;\n  });\n  document.addEventListener(\"\".concat(CLIENT_JOB_EVENT_PREFIX).concat(SCAN_QUEUE_JOB), async ({\n    detail: {\n      job: {\n        id,\n        data: {\n          url\n        },\n        process_total,\n        group_position,\n        group_total,\n        group_uuid\n      },\n      resolve,\n      reject,\n      saveJobResult\n    }\n  }) => {\n    const finalUrl = new URL(url);\n    applyQueryString(finalUrl, [{\n      \"rcb-scan\": 1,\n      \"rcb-scan-job\": id\n    }], true);\n    const link = \"<a href=\\\"\".concat(url, \"\\\" target=\\\"_blank\\\">\").concat(url, \"</a>\");\n\n    try {\n      const {\n        ok,\n        status,\n        statusText,\n        type,\n        headers\n      } = await window.fetch(finalUrl.toString(), {\n        mode: \"no-cors\"\n      });\n      const isCors = type === \"opaque\"; // Check if page could be scanned successfully\n\n      if (ok || // See https://developer.mozilla.org/en-US/docs/Web/API/Response/type\n      // We should definitely ignore CORS\n      isCors) {\n        var _headers$get;\n\n        // Immediate update the status to show at least \"1 %\" in tab\n        if (group_uuid && (group_position === group_total || group_position === 1)) {\n          fetchStatus(true);\n        } // A cors request never can mark the job as complete, we need to manually do this\n\n\n        if (isCors) {\n          await saveJobResult(id, process_total);\n        } // We requested a file (what does this do in our sitemap? Just ignore)\n\n\n        const contentType = (_headers$get = headers.get(\"content-type\")) === null || _headers$get === void 0 ? void 0 : _headers$get.toLowerCase();\n\n        if (contentType && !contentType.startsWith(\"text/\")) {\n          await saveJobResult(id, process_total);\n        }\n\n        resolve();\n      } else {\n        reject({\n          code: \"invalid_response_\".concat(status),\n          message: \"\".concat(statusText, \" (\").concat(link, \")\")\n        });\n      }\n    } catch (e) {\n      reject({\n        code: \"unexpected\",\n        message: \"\".concat(e.toString(), \" (\").concat(link, \")\")\n      });\n    }\n  });\n}\n\nexport { listenScannerJobExecution };","import { STATUS_ADDITIONAL_DATA_EVENT, STATUS_EVENT } from \"@devowl-wp/real-queue\";\nimport { SCAN_QUEUE_JOB } from \"../../types\";\nimport { __ } from \"../../utils\";\nimport $ from \"jquery\";\n\n/**\n * Add listener for the scanner status and automatically update the UI.\n */\nfunction listenScannerStatus() {\n  const adminBarNoticeElement = document.getElementById(\"rcb-scan-result-notice\");\n  const adminBarNoticeCounterElement = document.querySelector(\"#wp-admin-bar-rcb-scanner-found-services > a > span:nth-child(2)\");\n  let fetchAdditionalData = false; // Always refresh notice in admin bar with results\n\n  document.addEventListener(STATUS_ADDITIONAL_DATA_EVENT, async ({\n    detail: {\n      settings: {\n        additionalData\n      }\n    }\n  }) => {\n    if (adminBarNoticeElement && fetchAdditionalData) {\n      additionalData.push(\"rcb-scan-notice\");\n    }\n  });\n  document.addEventListener(STATUS_EVENT, ({\n    detail: {\n      currentJobs: {\n        [SCAN_QUEUE_JOB]: currentJob\n      },\n      remaining: {\n        [SCAN_QUEUE_JOB]: remainingArr\n      },\n      additionalData: {\n        \"rcb-scan-notice\": rcbScanNotice\n      }\n    }\n  }) => {\n    let percent = 100;\n    const hasFailureJobs = (remainingArr === null || remainingArr === void 0 ? void 0 : remainingArr[\"failure\"]) > 0; // Only show the badge for full scans\n\n    if (remainingArr && (currentJob === null || currentJob === void 0 ? void 0 : currentJob.group_position) > 0) {\n      const {\n        remaining,\n        total\n      } = remainingArr;\n      percent = +((total - remaining) / total * 100).toFixed(0);\n    }\n\n    const nowVisible = percent > 0 && percent < 100;\n    const statusElement = document.getElementById(\"rcb-scanner-status\");\n    const checklistExclamationMark = document.getElementById(\"rcb-checklist-overdue\");\n    fetchAdditionalData = nowVisible; // Update admin bar notice\n\n    if (adminBarNoticeElement && rcbScanNotice) {\n      adminBarNoticeElement.innerHTML = rcbScanNotice.text;\n      adminBarNoticeCounterElement.innerHTML = adminBarNoticeCounterElement.innerHTML.replace(/\\d+/, rcbScanNotice.countAll.toString());\n    }\n\n    if (statusElement) {\n      const previousVisible = statusElement.style.display !== \"none\";\n      statusElement.innerHTML = \"\".concat(percent, \" %\");\n      statusElement.style.display = nowVisible ? \"inline-block\" : \"none\"; // Hide checklist overdue when scanner is active\n\n      if (checklistExclamationMark) {\n        checklistExclamationMark.style.display = !nowVisible ? \"inline-block\" : \"none\";\n      } // Show message that it has finished\n\n\n      if (previousVisible && !nowVisible && !hasFailureJobs) {\n        try {\n          // Show for \"Scanner\" tab when active, or show on \"Cookies\" menu item when not in config page\n          const $handle = $(['#real-cookie-banner-component .nav-tab[href=\"#/scanner\"]:not(.nav-tab-active)', '#real-cookie-banner-pro-component .nav-tab[href=\"#/scanner\"]:not(.nav-tab-active)', \"body:not(.toplevel_page_real-cookie-banner-component) #toplevel_page_real-cookie-banner-component\", \"body:not(.toplevel_page_real-cookie-banner-pro-component) #toplevel_page_real-cookie-banner-pro-component\"].join(\",\"));\n          const isNavTab = $handle.hasClass(\"nav-tab\");\n          $handle.pointer({\n            content: \"<h3>\".concat(__(\"Real Cookie Banner has scanned your website!\"), \"</h3><p>\").concat(__('You may not have noticed, but we have been scanning your website in the background. View <a href=\"%s\">scanner results</a> to obtain consent for used services from your website visitors!', \"\".concat(isNavTab ? \"\" : $handle.find(\"a\").attr(\"href\"), \"#/scanner\")), \"</p>\"),\n            position: isNavTab ? {\n              edge: \"top\"\n            } : {\n              edge: \"left\",\n              align: \"bottom\"\n            },\n            pointerClass: \"wp-pointer arrow-\".concat(isNavTab ? \"top\" : \"bottom\"),\n            pointerWidth: 420\n          });\n          const widget = $handle.pointer(\"widget\");\n          widget.css({\n            marginLeft: -10\n          });\n\n          if (isNavTab) {\n            widget.find(\".wp-pointer-arrow\").css({\n              marginLeft: -38\n            });\n          }\n\n          $handle.pointer(\"open\");\n\n          if (isNavTab) {\n            $handle.add(widget.find(\"a\")).on(\"click\", () => {\n              $handle.pointer(\"destroy\");\n            });\n          }\n        } catch (e) {// jQuery or WP Pointer not available, but this does not matter\n        }\n      }\n    }\n  });\n}\n\nexport { listenScannerStatus };","import { CLIENT_JOB_EVENT_PREFIX } from \"@devowl-wp/real-queue\";\nimport { AUTOMATIC_SCAN_STATER_QUEUE_JOB } from \"../../types\";\nimport { refreshQueue, fetchStatus } from \"@devowl-wp/real-queue\";\nimport { locationRestScannerQueuePost } from \"../../wp-api\";\nimport { commonRequest } from \"@devowl-wp/utils\";\nimport { crawlSitemap } from \"./crawlSitemap\";\n/**\n * Add listener for the automatic scan starter.\n */\n\nfunction listenAutomaticScanStarterJobExecution() {\n  document.addEventListener(\"\".concat(CLIENT_JOB_EVENT_PREFIX).concat(AUTOMATIC_SCAN_STATER_QUEUE_JOB), async ({\n    detail: {\n      job: {\n        id,\n        process_total\n      },\n      resolve,\n      // reject,\n      saveJobResult\n    }\n  }) => {\n    // Hide scan button in scanner tab\n    let scanButton; // Periodically check for the scan button and hide it\n\n    const interval = setInterval(() => {\n      scanButton = document.getElementById(\"rcb-btn-scan-start\");\n\n      if (scanButton) {\n        scanButton.style.display = \"none\";\n      }\n    }, 1000);\n\n    try {\n      const sites = await crawlSitemap(); // Hacky get the REST options for `@devowl-wp/real-queue` as we have not\n      // RCB options available on all pages\n\n      const {\n        restRoot,\n        restNonce,\n        restQuery\n      } = window[\"realQueue\"];\n      const restNamespace = \"real-cookie-banner/v1\";\n      const options = {\n        restRoot,\n        restNamespace,\n        restNonce,\n        restQuery\n      };\n      await commonRequest({\n        location: locationRestScannerQueuePost,\n        options,\n        request: {\n          urls: sites,\n          purgeUnused: true\n        }\n      });\n      await refreshQueue();\n      fetchStatus(true);\n    } catch (e) {// reject({ code: \"rcb_sitemap_crawl\", message: e.message }); // See below\n    } finally {\n      clearInterval(interval);\n\n      if (scanButton) {\n        scanButton.style.removeProperty(\"display\");\n      } // Currently, we do not care about errors for the automatic starter\n\n\n      await saveJobResult(id, process_total);\n      resolve();\n    }\n  });\n}\n\nexport { listenAutomaticScanStarterJobExecution };"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","devowlWp_utils","devowlWp_realQueue","SCAN_QUEUE_JOB","FACTORY_MEMO","__","args","createLocalizationFactory","BaseOptions","jQuery","locationRestScannerQueuePost","path","method","RouteHttpVerb","REGEXP_URL_PATH","mapUrlToRootUrl","rootUrl","receivedUrl","query","_rootUrl$match","rootUrlPath","match","receivedQuery","useQuery","concat","substr","length","async","findByRobots","url","forceSitemapArgument","response","fetch","ok","correctedSitemapUrl","text","trim","responseCheckSitemap","body","test","e","KNOWN_FILENAMES","findByKnownFilenames","root","tryKnownFilenames","promises","map","filename","mode","promise","responseBody","indexOf","PSEUDO_URL_BASE","crawl","sitemapUrl","sites","document","DOMParser","parseFromString","parse","protocol","sitemapProtocol","URL","sitemapIndex","querySelector","indexUrls","Array","from","children","c","_c$querySelector","textContent","filter","Boolean","indexUrl","useUrl","urlSet","urls","_c$querySelector2","urlInstance","toString","push","console","error","sort","b","crawlSitemap","setStep","textOfferSupport","window","realCookieBannerQueue","originalHomeUrl","split","Promise","resolve","reject","resolver","result","setTimeout","robotsTxt","byKnownFilenames","robotsTxtForce","byKnownFilenamesCustom","findSitemap","Error","handleCorruptRestApi","addEventListener","JOB_DELAY_EVENT_PREFIX","detail","isIdle","settings","isInScannerTab","location","href","delay_ms","CLIENT_JOB_EVENT_PREFIX","job","id","data","process_total","group_position","group_total","group_uuid","saveJobResult","finalUrl","applyQueryString","link","status","statusText","type","headers","isCors","_headers$get","fetchStatus","contentType","toLowerCase","startsWith","code","message","adminBarNoticeElement","getElementById","adminBarNoticeCounterElement","fetchAdditionalData","STATUS_ADDITIONAL_DATA_EVENT","additionalData","STATUS_EVENT","currentJobs","currentJob","remaining","remainingArr","rcbScanNotice","percent","hasFailureJobs","total","toFixed","nowVisible","statusElement","checklistExclamationMark","innerHTML","replace","countAll","previousVisible","style","display","$handle","join","isNavTab","hasClass","pointer","content","find","attr","position","edge","align","pointerClass","pointerWidth","widget","css","marginLeft","add","on","listenScannerStatus","scanButton","interval","setInterval","restRoot","restNonce","restQuery","options","restNamespace","commonRequest","request","purgeUnused","refreshQueue","clearInterval","removeProperty"],"sourceRoot":""}