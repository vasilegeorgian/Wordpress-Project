{"version":3,"file":"index.js","mappings":"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","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///./lib/components/errorModal/listItem.tsx","webpack:///./lib/components/errorModal/list.tsx","webpack:///./lib/components/errorModal/modal.tsx","webpack:///./lib/components/provider.tsx","webpack:///./lib/hooks/useProgress.tsx","webpack:///./lib/hooks/useStatusErrors.tsx","webpack:///./lib/index.tsx","webpack:///./lib/queue/activityDetector.tsx","webpack:///./lib/queue/client/clientJobToPromise.tsx","webpack:///./lib/queue/client/executor.tsx","webpack:///./lib/queue/fetchStatus.tsx","webpack:///./lib/queue/global.tsx","webpack:///./lib/queue/job/delay.tsx","webpack:///./lib/queue/job/deleteJobs.tsx","webpack:///./lib/queue/job/fetchJob.tsx","webpack:///./lib/queue/job/jobToPopulateNextJobs.tsx","webpack:///./lib/queue/job/retryJobs.tsx","webpack:///./lib/queue/job/saveJobResult.tsx","webpack:///./lib/queue/job/skipJobs.tsx","webpack:///./lib/queue/queueClass.tsx","webpack:///./lib/queue/refreshQueue.tsx","webpack:///./lib/queue/restoreFromLocalStorage.tsx","webpack:///./lib/queue/server/executor.tsx","webpack:///./lib/queue/server/serverJobToPromise.tsx","webpack:///./lib/queue/tabBridge/checkNotifications.tsx","webpack:///./lib/queue/tabBridge/clearNotifications.tsx","webpack:///./lib/queue/tabBridge/lockTab.tsx","webpack:///./lib/queue/tabBridge/notifyWorkerTab.tsx","webpack:///./lib/types/events/clientJob.tsx","webpack:///./lib/types/events/jobDelay.tsx","webpack:///./lib/types/events/jobDone.tsx","webpack:///./lib/types/events/jobsDeleted.tsx","webpack:///./lib/types/events/jobsRetried.tsx","webpack:///./lib/types/events/jobsSkipped.tsx","webpack:///./lib/types/events/remaining.tsx","webpack:///./lib/types/events/status.tsx","webpack:///./lib/types/events/statusAdditionalData.tsx","webpack:///./lib/utils/i18n.tsx","webpack:///./lib/utils/index.tsx","webpack:///./lib/utils/localStorageTest.tsx","webpack:///./lib/utils/ready.tsx","webpack:///./lib/utils/request.tsx","webpack:///./lib/utils/waitObject.tsx","webpack:///./lib/wp-api/job.get.tsx","webpack:///./lib/wp-api/job.post.tsx","webpack:///./lib/wp-api/jobResult.post.tsx","webpack:///./lib/wp-api/jobs.delete.tsx","webpack:///./lib/wp-api/jobs.get.tsx","webpack:///./lib/wp-api/jobsRetry.post.tsx","webpack:///./lib/wp-api/jobsSkip.post.tsx","webpack:///./lib/wp-api/status.get.tsx","webpack:///external var \"React\"","webpack:///external var \"ReactDOM\"","webpack:///external var \"devowlWp_utils\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import _Spin from \"antd/es/spin\";\nimport _List from \"antd/es/list\";\nimport _Dropdown from \"antd/es/dropdown\";\nimport _Menu from \"antd/es/menu\";\nimport { useState, useCallback } from \"react\";\nimport { __ } from \"../../utils\";\nimport { deleteJobs, retryJobs, skipJobs } from \"../../queue\";\n\nconst ErrorModalListItem = ({\n  item: {\n    actions,\n    type,\n    label,\n    description,\n    failedJobs\n  }\n}) => {\n  const [busy, setBusy] = useState(false);\n  const handleDelete = useCallback(async () => {\n    setBusy(true);\n\n    try {\n      await deleteJobs({\n        type\n      });\n    } finally {\n      setBusy(false);\n    }\n  }, [type]);\n  const handleRetry = useCallback(async () => {\n    setBusy(true);\n\n    try {\n      await retryJobs({\n        type\n      });\n    } finally {\n      setBusy(false);\n    }\n  }, [type]);\n  const handleSkip = useCallback(async () => {\n    setBusy(true);\n\n    try {\n      await skipJobs({\n        type\n      });\n    } finally {\n      setBusy(false);\n    }\n  }, [type]);\n  const useActionText = useCallback((action, defaultText) => {\n    var _actions$filter$;\n\n    return ((_actions$filter$ = actions.filter(({\n      action: a\n    }) => action === a)[0]) === null || _actions$filter$ === void 0 ? void 0 : _actions$filter$.linkText) || defaultText;\n  }, [actions]);\n  return /*#__PURE__*/React.createElement(_Spin, {\n    spinning: busy\n  }, /*#__PURE__*/React.createElement(_List.Item, {\n    style: {\n      paddingLeft: 0,\n      paddingRight: 0\n    },\n    actions: [/*#__PURE__*/React.createElement(_Dropdown.Button, {\n      key: \"test\",\n      onClick: handleRetry,\n      overlay: /*#__PURE__*/React.createElement(_Menu, null, /*#__PURE__*/React.createElement(_Menu.Item, {\n        onClick: handleSkip\n      }, useActionText(\"skip\", __(\"Skip failed jobs\"))), actions.map(({\n        action,\n        url,\n        linkText,\n        target = \"_blank\"\n      }) => !action && /*#__PURE__*/React.createElement(_Menu.Item, {\n        key: url,\n        onClick: () => window.open(url, \"_blank\")\n      }, linkText)).filter(Boolean), /*#__PURE__*/React.createElement(_Menu.Item, {\n        danger: true,\n        onClick: handleDelete\n      }, useActionText(\"delete\", __(\"Cancel process\"))))\n    }, useActionText(\"retry\", __(\"Retry\")))]\n  }, /*#__PURE__*/React.createElement(_List.Item.Meta, {\n    title: label,\n    description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", null, description), /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        marginTop: 10\n      }\n    }, /*#__PURE__*/React.createElement(\"strong\", null, __(\"Error message:\"))), failedJobs.slice(0, 1).map(job => {\n      const {\n        id,\n        exception: {\n          errors\n        }\n      } = job;\n      return /*#__PURE__*/React.createElement(\"div\", {\n        \"data-job\": id,\n        key: id,\n        onClick: () => console.log(job)\n      }, Object.keys(errors).map(code => /*#__PURE__*/React.createElement(\"div\", {\n        key: code,\n        \"data-code\": code,\n        dangerouslySetInnerHTML: {\n          __html: errors[code].join(\"<br />\")\n        }\n      })));\n    }))\n  })));\n};\n\nexport { ErrorModalListItem };","import _List from \"antd/es/list\";\nimport { ErrorModalListItem } from \".\";\n\nconst ErrorModalList = ({\n  list\n}) => {\n  return /*#__PURE__*/React.createElement(_List, {\n    size: \"small\",\n    dataSource: Object.values(list),\n    renderItem: item => /*#__PURE__*/React.createElement(ErrorModalListItem, {\n      item: item,\n      key: item.type\n    })\n  });\n};\n\nexport { ErrorModalList };","import _Modal from \"antd/es/modal\";\nimport { useState, useEffect } from \"react\";\nimport { useStatusErrors } from \"../../hooks\";\nimport { __ } from \"../../utils\";\nimport { ErrorModalList } from \".\";\n\nconst ErrorModal = () => {\n  const {\n    errors\n  } = useStatusErrors();\n  const [visible, setVisible] = useState(false);\n  useEffect(() => {\n    const {\n      activeElement\n    } = document;\n    const hasErrors = Object.values(errors).length > 0;\n\n    if (hasErrors) {\n      if (activeElement && (/^(?:input|select|textarea|button)$/i.test(activeElement.nodeName) || activeElement.hasAttribute(\"contenteditable\"))) {\n        setVisible(false);\n\n        const listener = () => {\n          setVisible(true);\n        };\n\n        activeElement.addEventListener(\"blur\", listener, {\n          once: true\n        });\n        return () => {\n          activeElement.removeEventListener(\"blur\", listener);\n        };\n      } else {\n        setVisible(true);\n      }\n    } else {\n      setVisible(false);\n    }\n\n    return () => {// Silence is golden.\n    };\n  }, [errors]);\n  return /*#__PURE__*/React.createElement(_Modal, {\n    className: \"real-queue-error-modal\",\n    footer: null,\n    title: __(\"Background tasks: Something went wrong\"),\n    visible: visible,\n    width: 750,\n    closable: false\n  }, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", {\n    className: \"description\"\n  }, __(\"Your WordPress installation is working in the background on tasks that you basically don't notice. Unfortunately, an error occurred while running a task. Below is a list of failed tasks that you can either delete (and thus cancel the task) or try again.\")), /*#__PURE__*/React.createElement(ErrorModalList, {\n    list: errors\n  })));\n};\n\nexport { ErrorModal };","import _ConfigProvider from \"antd/es/config-provider\";\n\nconst Provider = ({\n  children\n}) => /*#__PURE__*/React.createElement(_ConfigProvider, {\n  prefixCls: process.env.ANTD_PREFIX\n}, children);\n\nexport { Provider };","import { useCallback, useEffect, useState } from \"react\";\nimport { deleteJobs, fetchStatus } from \"../queue\";\nimport { JOBS_DELETED_EVENT, STATUS_ADDITIONAL_DATA_EVENT, STATUS_EVENT } from \"../types\";\nimport { useStatusErrors } from \"./useStatusErrors\";\n\nfunction useProgress({\n  type,\n  fetchStatusInterval,\n  fetchAdditionalData = false,\n  onAdditionalData,\n  onCancel\n}) {\n  const [cancelling, setCancelling] = useState(false);\n  const [jobsStarted, setJobsStarted] = useState(false);\n  const [remaining, setRemaining] = useState();\n  const [percent, setPercent] = useState();\n  const [total, setTotal] = useState();\n  const [failure, setFailure] = useState();\n  const [paused, setPaused] = useState();\n  const [currentJob, setCurrentJob] = useState();\n  const {\n    errors: {\n      [type]: errors\n    }\n  } = useStatusErrors(); // Determine status\n\n  let status = \"not-started\";\n\n  if (jobsStarted) {\n    if (errors) {\n      status = \"failed\";\n    } else if (remaining === 0 && !failure) {\n      status = \"done\";\n    }\n  } // Listen to status updates\n\n\n  const listener = useCallback(async ({\n    detail: {\n      currentJobs,\n      remaining: {\n        [type]: remainingArr\n      },\n      additionalData\n    }\n  }) => {\n    if (remainingArr) {\n      const {\n        remaining,\n        total,\n        failure,\n        paused\n      } = remainingArr;\n      const percent = +((total - remaining) / total * 100).toFixed(0);\n      setCurrentJob(currentJobs[type]);\n      setRemaining(remaining);\n      setTotal(total);\n      setFailure(failure);\n      setPaused(paused);\n      setPercent(percent > 0 ? percent : 1);\n    } else {\n      setCurrentJob(undefined);\n      setRemaining(0);\n      setTotal(0);\n      setFailure(0);\n      setPaused(0);\n      setPercent(100);\n    } // Always handle the received response, too\n\n\n    if (fetchAdditionalData !== false && additionalData[fetchAdditionalData]) {\n      onAdditionalData(additionalData);\n    }\n  }, [type, onAdditionalData, fetchAdditionalData]); // Listen to all status updated\n\n  useEffect(() => {\n    document.addEventListener(STATUS_EVENT, listener);\n    return () => {\n      document.removeEventListener(STATUS_EVENT, listener);\n    };\n  }, [listener]);\n  useEffect(() => {\n    if (remaining > 0) {\n      setJobsStarted(true);\n    }\n  }, [remaining]); // Let the status updater know that we want to fetch additional data\n\n  useEffect(() => {\n    if (fetchAdditionalData) {\n      const listener = async ({\n        detail: {\n          settings: {\n            additionalData\n          }\n        }\n      }) => {\n        additionalData.push(fetchAdditionalData);\n      };\n\n      document.addEventListener(STATUS_ADDITIONAL_DATA_EVENT, listener);\n      return () => {\n        document.removeEventListener(STATUS_ADDITIONAL_DATA_EVENT, listener);\n      };\n    }\n\n    return () => {// Silence is golden.\n    };\n  }, [fetchAdditionalData]);\n  const applyCancelState = useCallback(() => {\n    setJobsStarted(false);\n    setCurrentJob(undefined);\n    setRemaining(0);\n    setTotal(0);\n    setFailure(0);\n    setPaused(0);\n    setPercent(100);\n    onCancel === null || onCancel === void 0 ? void 0 : onCancel();\n  }, [onCancel]); // Listen to manual deletion of tasks in the error modal\n\n  useEffect(() => {\n    const listenerDeleted = async ({\n      detail: {\n        params: {\n          type: deletedType\n        }\n      }\n    }) => {\n      if (deletedType === type) {\n        applyCancelState();\n      }\n    };\n\n    document.addEventListener(JOBS_DELETED_EVENT, listenerDeleted);\n    return () => {\n      document.removeEventListener(JOBS_DELETED_EVENT, listenerDeleted);\n    };\n  }, [listener, applyCancelState]);\n  const handleCancel = useCallback(async () => {\n    applyCancelState();\n    setCancelling(true);\n    await deleteJobs({\n      type\n    });\n    setCancelling(false);\n  }, [type, applyCancelState]); // Modify the status updater\n\n  useEffect(() => {\n    if (fetchStatusInterval > 0) {\n      fetchStatus(fetchStatusInterval, true);\n      return () => {\n        fetchStatus();\n      };\n    }\n\n    return () => {// Silence is golden.\n    };\n  }, [fetchStatusInterval]);\n  return {\n    errors,\n    status,\n    jobsStarted,\n    remaining,\n    percent,\n    total,\n    failure,\n    paused,\n    currentJob,\n    handleCancel,\n    cancelling\n  };\n}\n\nexport { useProgress };","import { STATUS_EVENT } from \"../types\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { getStaticOptions } from \"../utils\";\n/**\n * Listen to the queue status and automatically create a state with the errors.\n */\n\nfunction useStatusErrors() {\n  const [, setPreviousHash] = useState();\n  const [errors, setErrors] = useState({});\n  const applyErrors = useCallback((hash, list) => setPreviousHash(previousHash => {\n    if (previousHash !== hash) {\n      setErrors(list);\n      return hash;\n    }\n\n    return previousHash;\n  }), []);\n  const listener = useCallback(async ({\n    detail: {\n      errors: {\n        hash,\n        list\n      }\n    }\n  }) => {\n    applyErrors(hash, list);\n  }, []);\n  useEffect(() => {\n    // Initial state\n    const {\n      hash,\n      list\n    } = getStaticOptions().errors;\n    applyErrors(hash, list);\n    document.addEventListener(STATUS_EVENT, listener);\n    return () => {\n      document.removeEventListener(STATUS_EVENT, listener);\n    };\n  }, []);\n  return {\n    errors\n  };\n}\n\nexport { useStatusErrors };","/* istanbul ignore file: we do not need to care about the entry point file as errors are detected through integration tests (E2E) */\n\n/**\n * The entry point for the admin side wp-admin resource.\n */\nimport { fetchStatus, refreshQueue, restoreJobsFromLocalStorage, lockTab, createActivityDetector, clearWorkerNotifications, checkWorkerNotifications } from \"./queue\";\nimport { CLIENT_JOB_EVENT_PREFIX } from \"./types\";\nimport { ready, waitObject } from \"./utils\";\nimport \"./style/antd.less\";\nimport \"./style/index.scss\";\nimport { ErrorModal, Provider } from \"./components\";\nimport { render } from \"react-dom\";\nready(async () => {\n  // Only allow queue runtime for one tab\n  await waitObject(() => lockTab() ? undefined : \"unlocked\", 3000);\n  window.addEventListener(\"beforeunload\", () => lockTab(false));\n  lockTab(true); // Create error modal\n\n  const errorModalElement = document.createElement(\"div\");\n  document.body.appendChild(errorModalElement);\n  render( /*#__PURE__*/React.createElement(Provider, null, /*#__PURE__*/React.createElement(ErrorModal, null)), errorModalElement); // Mark this tab as worker\n\n  clearWorkerNotifications();\n  window.realQueueWorker = true;\n  setInterval(() => checkWorkerNotifications({\n    refreshQueue\n  }), 3000);\n  const addedFromLocalStorage = await restoreJobsFromLocalStorage();\n\n  if (!addedFromLocalStorage) {\n    // No new items from LocalStorage, check if queue has new items\n    refreshQueue();\n  }\n}, \"interactive\");\nready(() => {\n  createActivityDetector();\n  fetchStatus(15000, true); // When the tab gets visible, immediate fetch status\n\n  document.addEventListener(\"visibilitychange\", () => {\n    if (document.visibilityState === \"visible\") {\n      fetchStatus(true);\n    }\n  });\n}); // Example implementation of a client job\n\ndocument.addEventListener(\"\".concat(CLIENT_JOB_EVENT_PREFIX, \"example\"), async ({\n  detail: {\n    job,\n    resolve,\n    fetchJob,\n    saveJobResult\n  }\n}) => {\n  console.log(\"Lock this job and sleep...\", job);\n  const {\n    id,\n    process_total\n  } = job;\n  await fetchJob(id, true);\n  await new Promise(resolve => setTimeout(resolve, 5000));\n  saveJobResult(id, process_total);\n  resolve();\n});\nexport * from \"./hooks\";\nexport * from \"./types\";\nexport * from \"./utils\";\nexport * from \"./queue\";\nexport * from \"./wp-api\";","import create from \"activity-detector\";\nconst WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY = \"realQueueIsIdle\";\n\n/**\n * Detect idle time. You can get the state from `window.realQueueIsIdle [boolean]`.\n */\nfunction createActivityDetector() {\n  const activityDetector = create({\n    autoInit: false\n  });\n  activityDetector.on(\"idle\", () => {\n    window[WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY] = true;\n  });\n  activityDetector.on(\"active\", () => {\n    window[WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY] = false;\n  }); // I want to start the activity detector now!\n\n  activityDetector.init();\n}\n\nexport { createActivityDetector, WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY };","import { JOB_DONE_EVENT_PREFIX } from \"../../types\";\nimport { REMAINING_EVENT } from \"../../types\";\nimport { executeClientJob } from \".\";\nimport { getStaticOptions } from \"../../utils\";\nimport { jobDelay } from \"..\";\n/**\n * Convert a client job to promise.\n */\n\nfunction convertClientJobToPromise(queue, job) {\n  const {\n    type\n  } = job;\n\n  const fn = async () => {\n    const updateRemaining = () => {\n      const {\n        remaining\n      } = getStaticOptions();\n\n      if (remaining[type]) {\n        remaining[type][0] -= 1;\n      }\n\n      document.dispatchEvent(new CustomEvent(REMAINING_EVENT, {\n        detail: {\n          remaining\n        }\n      }));\n    };\n\n    try {\n      const success = await executeClientJob(job);\n      updateRemaining();\n      document.dispatchEvent(new CustomEvent(\"\".concat(JOB_DONE_EVENT_PREFIX).concat(type), {\n        detail: {\n          job,\n          success\n        }\n      }));\n    } catch (e) {\n      // Something went wrong between request and executor - we pause the queue here cause\n      // we wait for the next refresh of the page.\n      queue.pause();\n    }\n  };\n\n  const delay = () => jobDelay(job);\n\n  return [fn, delay];\n}\n\nexport { convertClientJobToPromise };","import { CLIENT_JOB_EVENT_PREFIX } from \"../../types\";\nimport { LOCAL_STORAGE_KEY_RESTORE_JOBS, fetchJob, saveJobResult, jobDelay } from \"..\";\nimport { getStaticOptions, localStorageTest } from \"../../utils\";\n/**\n * Execute a client job.\n */\n\nasync function executeClientJob(job, run = 0) {\n  let result = false;\n  const {\n    id,\n    type,\n    retries\n  } = job;\n\n  try {\n    await new Promise((resolve, reject) => {\n      document.dispatchEvent(new CustomEvent(\"\".concat(CLIENT_JOB_EVENT_PREFIX).concat(type), {\n        detail: {\n          job,\n          resolve,\n          reject,\n          run,\n          fetchJob,\n          saveJobResult\n        }\n      }));\n    });\n    result = true;\n  } catch (e) {\n    if (run < retries) {\n      await jobDelay(job);\n      result = await executeClientJob(job, run + 1);\n    } else {\n      await saveJobResult(id, 0, e);\n      result = false;\n    }\n  } // Remove from our localStorage, as we do not need to restore it no longer\n\n\n  if (run === 0 && localStorageTest()) {\n    var _localStorage$getItem;\n\n    const lsKey = \"\".concat(LOCAL_STORAGE_KEY_RESTORE_JOBS, \"-\").concat(getStaticOptions().localStorageSuffix);\n    const restorable = ((_localStorage$getItem = localStorage.getItem(lsKey)) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.split(\",\").map(Number)) || [];\n    const idx = restorable.indexOf(id);\n\n    if (idx > -1) {\n      restorable.splice(idx, 1);\n    }\n\n    localStorage.setItem(lsKey, restorable.join(\",\"));\n  }\n\n  return result;\n}\n\nexport { executeClientJob };","import { STATUS_ADDITIONAL_DATA_EVENT } from \"../types\";\nimport { STATUS_EVENT } from \"../types\";\nimport { request } from \"../utils\";\nimport { locationRestStatusGet } from \"../wp-api\";\nimport { getGlobalQueue, refreshQueue } from \".\";\nlet timeout;\nlet currentlyFetching = false;\n/**\n * Fetch the status of the complete queue in a given interval. In general, the queue pulls always\n * the status, but you could change the interval to provide a more \"up-to-date\" UI to your users.\n *\n * You need to listen to the fetch-status event.\n */\n\nasync function fetchStatus(intervalOrImmediate = 15000, immediate = false) {\n  const fn = async () => {\n    if (currentlyFetching) {\n      // There is still a request, skip this interval\n      return;\n    }\n\n    if (!window.realQueueWorker && document.visibilityState === \"hidden\") {\n      // This tab is currently not working, skip status if tab is inactive\n      return;\n    }\n\n    currentlyFetching = true;\n\n    try {\n      const settings = {\n        additionalData: []\n      };\n      document.dispatchEvent(new CustomEvent(STATUS_ADDITIONAL_DATA_EVENT, {\n        detail: {\n          settings\n        }\n      }));\n      const detail = await request({\n        location: locationRestStatusGet,\n        params: {\n          additionalData: settings.additionalData.join(\",\")\n        }\n      });\n      document.dispatchEvent(new CustomEvent(STATUS_EVENT, {\n        detail\n      })); // Check if the queue is currently empty, but there are still remaining items, try to get them\n\n      const {\n        remaining,\n        errors\n      } = detail;\n\n      if ( // Only the worker should refresh the queue as needed\n      window.realQueueWorker && getGlobalQueue().size === 0 && Object.values(remaining).length > 0 && // Do not load new items to the queue until the errors are resolved\n      Object.values(errors.list).length === 0) {\n        refreshQueue(false);\n      }\n    } finally {\n      currentlyFetching = false;\n    }\n  };\n\n  if (typeof intervalOrImmediate === \"number\") {\n    clearInterval(timeout);\n    timeout = setInterval(() => fn(), intervalOrImmediate);\n    immediate && (await fn());\n  } else if (intervalOrImmediate === true) {\n    await fn();\n  }\n}\n\nexport { fetchStatus };","import PQueue from \"p-queue\";\nimport { RealQueueClass } from \".\";\n\n/**\n * Create a page-wide queue saved in `window`.\n */\nfunction getGlobalQueue() {\n  if (!window.realQueueInstance) {\n    const queue = new PQueue({\n      autoStart: true,\n      concurrency: 1,\n      queueClass: RealQueueClass\n    }); // By default, the p-queue does not expose the queue class\n\n    queue.enqueueHandler = function () {\n      return this._queue;\n    }; // This is a bit hacky, but currently the only way to access the parent instance (?!)\n\n\n    window.realQueueInstance = queue;\n    window.realQueueInstance.enqueueHandler().setHandler(window.realQueueInstance);\n  }\n\n  return window.realQueueInstance;\n}\n\nexport { getGlobalQueue };","import { WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY } from \"..\";\nimport { JOB_DELAY_EVENT_PREFIX } from \"../../types\";\n/**\n * Delay a job with the defined `delay_ms`.\n */\n\nfunction jobDelay(job) {\n  const isIdle = !!window[WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY];\n  const {\n    type,\n    delay_ms\n  } = job;\n  const settings = {\n    delay_ms\n  };\n  document.dispatchEvent(new CustomEvent(\"\".concat(JOB_DELAY_EVENT_PREFIX).concat(type), {\n    detail: {\n      job,\n      isIdle,\n      settings\n    }\n  }));\n  return new Promise(resolve => setTimeout(resolve, settings.delay_ms));\n}\n\nexport { jobDelay };","import { JOBS_DELETED_EVENT } from \"../../types\";\nimport { request } from \"../../utils\";\nimport { locationRestJobsDelete } from \"../../wp-api\";\nimport { fetchStatus } from \"..\";\n/**\n * Delete jobs by e.g. type. This is similar to a \"Cancel\" button.\n */\n\nasync function deleteJobs(params) {\n  const response = await request({\n    location: locationRestJobsDelete,\n    params\n  });\n  document.dispatchEvent(new CustomEvent(JOBS_DELETED_EVENT, {\n    detail: {\n      params,\n      response\n    }\n  }));\n  await fetchStatus(true);\n  return response;\n}\n\nexport { deleteJobs };","import { request } from \"../../utils\";\nimport { locationRestJobGet } from \"../../wp-api\";\n/**\n * Fetch job by id. Additionally, you can set a `lock` boolean so other tabs could\n * not process this job furthermore. This is useful for client jobs.\n */\n\nasync function fetchJob(id, lock) {\n  return await request({\n    location: locationRestJobGet,\n    params: {\n      id,\n      lock\n    }\n  });\n}\n\nexport { fetchJob };","import { REMAINING_EVENT } from \"../../types\";\nimport { getStaticOptions, request } from \"../../utils\";\nimport { locationRestJobsGet } from \"../../wp-api\";\nimport { getGlobalQueue } from \"..\";\n/**\n * Fetch the next list of jobs so we can populate to our queue.\n */\n\nfunction createJobToPopulateNextJobs(afterJobId, queueClass = getGlobalQueue().enqueueHandler()) {\n  return async () => {\n    try {\n      const {\n        jobs,\n        remaining\n      } = await request({\n        location: locationRestJobsGet,\n        params: {\n          after: afterJobId\n        }\n      });\n      getStaticOptions().remaining = remaining;\n      document.dispatchEvent(new CustomEvent(REMAINING_EVENT, {\n        detail: {\n          remaining\n        }\n      }));\n      queueClass.enqueueFromList(jobs);\n    } catch (e) {\n      // Something went wrong between request and WP REST API - we pause the queue here cause\n      // we wait for the next refresh of the page - the REST API response is always valid and\n      // does not throw any error\n      queueClass.handler.pause();\n    }\n  };\n}\n\nexport { createJobToPopulateNextJobs };","import { JOBS_RETRIED_EVENT } from \"../../types\";\nimport { request as utilsRequest } from \"../../utils\";\nimport { locationRestJobsRetryPost } from \"../../wp-api\";\nimport { fetchStatus } from \"..\";\n/**\n * Retry jobs by e.g. type. This is similar to a \"Cancel\" button.\n */\n\nasync function retryJobs(request) {\n  const response = await utilsRequest({\n    location: locationRestJobsRetryPost,\n    request\n  });\n  document.dispatchEvent(new CustomEvent(JOBS_RETRIED_EVENT, {\n    detail: {\n      request,\n      response\n    }\n  }));\n  await fetchStatus(true);\n}\n\nexport { retryJobs };","import { JOBS_DELETED_EVENT, JOBS_RETRIED_EVENT, JOBS_SKIPPED_EVENT } from \"../../types\";\nimport { request } from \"../../utils\";\nimport { locationRestJobResultPost } from \"../../wp-api\";\n\nasync function saveJobResult(id, process, exception = {}) {\n  const {\n    code: errorCode,\n    message: errorMessage,\n    data: errorData\n  } = exception;\n\n  try {\n    const result = await request({\n      location: locationRestJobResultPost,\n      request: {\n        process,\n        errorCode,\n        errorMessage,\n        errorData: errorData ? JSON.stringify(errorData) : undefined\n      },\n      params: {\n        id\n      }\n    });\n\n    if (result.pauseToAvoidRecurringException) {\n      await new Promise(resolve => {\n        const {\n          job: {\n            type\n          }\n        } = result; // Wait for user reactivates (delete, retry) the job\n\n        const listenerDeleted = async ({\n          detail: {\n            params: {\n              type: deletedType\n            }\n          }\n        }) => {\n          if (deletedType === type) {\n            document.removeEventListener(JOBS_DELETED_EVENT, listenerDeleted);\n            resolve();\n          }\n        };\n\n        const listenerRetried = async ({\n          detail: {\n            request: {\n              type: retriedType\n            }\n          }\n        }) => {\n          if (retriedType === type) {\n            document.removeEventListener(JOBS_RETRIED_EVENT, listenerRetried);\n            resolve();\n          }\n        };\n\n        const listenerSkipped = async ({\n          detail: {\n            request: {\n              type: skippedType\n            }\n          }\n        }) => {\n          if (skippedType === type) {\n            document.removeEventListener(JOBS_RETRIED_EVENT, listenerRetried);\n            resolve();\n          }\n        };\n\n        document.addEventListener(JOBS_DELETED_EVENT, listenerDeleted);\n        document.addEventListener(JOBS_RETRIED_EVENT, listenerRetried);\n        document.addEventListener(JOBS_SKIPPED_EVENT, listenerSkipped);\n      });\n    }\n\n    return result;\n  } catch (e) {\n    // Something went wrong - but this should not be the case as we should always be able to store\n    // job results. Let's wait a bit and try again\n    await new Promise(resolve => setTimeout(resolve, 60 * 1000));\n    return await saveJobResult(id, process, exception);\n  }\n}\n\nexport { saveJobResult };","import { JOBS_RETRIED_EVENT } from \"../../types\";\nimport { request as utilsRequest } from \"../../utils\";\nimport { locationRestJobsSkipPost } from \"../../wp-api\";\nimport { fetchStatus } from \"..\";\n/**\n * Skip jobs by e.g. type.\n */\n\nasync function skipJobs(request) {\n  const response = await utilsRequest({\n    location: locationRestJobsSkipPost,\n    request\n  });\n  document.dispatchEvent(new CustomEvent(JOBS_RETRIED_EVENT, {\n    detail: {\n      request,\n      response\n    }\n  }));\n  await fetchStatus(true);\n}\n\nexport { skipJobs };","import { JOBS_DELETED_EVENT, JOBS_RETRIED_EVENT, JOB_DONE_EVENT_PREFIX } from \"../types\";\nimport { createJobToPopulateNextJobs, LOCAL_STORAGE_KEY_RESTORE_JOBS, convertClientJobToPromise, convertServerJobToPromise } from \".\";\nimport { getStaticOptions, localStorageTest } from \"../utils\";\n\n/**\n * This class should be minimal so we can control the queue items itself.\n *\n * @see https://github.com/sindresorhus/p-queue#custom-RealQueueClass\n * @see https://github.com/sindresorhus/p-queue/blob/76b81cd707a6cd31b41f25e5d7fa8abc7486c4bf/source/priority-queue.ts#L12\n */\nclass RealQueueClass {\n  constructor() {\n    this.queue = [];\n    this.alreadyAddedJobIds = [];\n    this._handler = void 0;\n    this.queue = [];\n    this.listenRetries();\n    this.listenDeletions();\n  }\n\n  enqueueFromList(list) {\n    const tryJobIds = list.filter(({\n      worker\n    }) => worker === \"server\").map(({\n      id\n    }) => id);\n    const jobs = [];\n    const {\n      handler,\n      alreadyAddedJobIds\n    } = this;\n\n    for (const job of list) {\n      const {\n        id,\n        type\n      } = job; // Avoid duplicate items\n\n      if (alreadyAddedJobIds.indexOf(id) > -1) {\n        continue;\n      }\n\n      if (job.worker === \"client\") {\n        jobs.push({\n          runs: convertClientJobToPromise(handler, job),\n          job\n        });\n      } else {\n        // The next request is not allowed to retry the previous one\n        tryJobIds.splice(tryJobIds.indexOf(id), 1);\n        jobs.push({\n          runs: convertServerJobToPromise(handler, job, [\n          /* pass immutable */\n          ...tryJobIds]),\n          job\n        });\n      }\n\n      alreadyAddedJobIds.push(id); // Listen to failed job and make the job available again to retry\n\n      const listenerFailedEvent = \"\".concat(JOB_DONE_EVENT_PREFIX).concat(type);\n\n      const listenerFailed = ({\n        detail: {\n          job: {\n            id: doneJobId\n          },\n          success\n        }\n      }) => {\n        if (doneJobId === id && !success) {\n          document.removeEventListener(listenerFailedEvent, listenerFailed);\n          const alreadyIdx = this.alreadyAddedJobIds.indexOf(doneJobId);\n\n          if (alreadyIdx > -1) {\n            this.alreadyAddedJobIds.splice(alreadyIdx, 1);\n          }\n        }\n      };\n\n      document.addEventListener(listenerFailedEvent, listenerFailed);\n    } // Add a refresh job to populate our queue with the next \"list\"\n\n\n    if (jobs.length > 0) {\n      const previousAt = jobs.length > 40 ? 10 : 0;\n      const {\n        job: previousJob\n      } = jobs[previousAt];\n      jobs.splice(jobs.length - previousAt, 0, {\n        runs: [createJobToPopulateNextJobs(list[list.length - 1].id, this)],\n        job: previousJob\n      });\n    } // Make this list restorable from the localStorage\n\n\n    if (localStorageTest()) {\n      var _localStorage$getItem;\n\n      const lsKey = \"\".concat(LOCAL_STORAGE_KEY_RESTORE_JOBS, \"-\").concat(getStaticOptions().localStorageSuffix);\n      const restorable = ((_localStorage$getItem = localStorage.getItem(lsKey)) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.split(\",\").map(Number)) || [];\n      list.forEach(({\n        id\n      }) => restorable.indexOf(id) === -1 && restorable.push(id));\n      localStorage.setItem(lsKey, restorable.join(\",\"));\n    }\n\n    jobs.forEach(({\n      job,\n      runs\n    }) => {\n      handler.addAll(runs, {\n        job\n      });\n    });\n  }\n\n  enqueue(run, options) {\n    if (!(options !== null && options !== void 0 && options.job)) {\n      throw new Error(\"Please provide a job object!\");\n    }\n\n    const {\n      job: {\n        id,\n        type\n      }\n    } = options;\n    const element = { ...options,\n      id,\n      type,\n      run\n    };\n    this.queue.push(element);\n  }\n\n  dequeue() {\n    const item = this.queue.shift();\n    return item === null || item === void 0 ? void 0 : item.run;\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n\n  filterQueueItem(options) {\n    return this.queue.filter(({\n      id,\n      type\n    }) => {\n      if (typeof options.id !== \"undefined\" && id !== options.id) {\n        return false;\n      }\n\n      if (typeof options.type !== \"undefined\" && type !== options.type) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  filter(options) {\n    return this.filterQueueItem(options).map(element => element.run);\n  }\n\n  get handler() {\n    return this._handler;\n  }\n\n  setHandler(handler) {\n    this._handler = handler;\n  }\n\n  removeByType(type, forgetAboutAlreadyAdded = true) {\n    const removedIds = [];\n    this.queue = this.queue.filter(item => {\n      const result = item.type !== type;\n\n      if (!result) {\n        removedIds.push(item.id);\n      }\n\n      return result;\n    });\n\n    if (forgetAboutAlreadyAdded) {\n      this.alreadyAddedJobIds = this.alreadyAddedJobIds.filter(id => removedIds.indexOf(id) === -1);\n    }\n  }\n  /**\n   * Listen if jobs got deleted, remove them from the queue so they never get executed again.\n   */\n\n\n  listenDeletions() {\n    const listener = async ({\n      detail: {\n        params: {\n          type\n        }\n      }\n    }) => {\n      this.removeByType(type, false);\n    };\n\n    document.addEventListener(JOBS_DELETED_EVENT, listener);\n  }\n  /**\n   * Listen if jobs got retried, remove them from the queue so they can be added again.\n   */\n\n\n  listenRetries() {\n    const listener = async ({\n      detail: {\n        request: {\n          type\n        }\n      }\n    }) => {\n      this.removeByType(type);\n    };\n\n    document.addEventListener(JOBS_RETRIED_EVENT, listener);\n  }\n\n}\n\nexport { RealQueueClass };","import { createJobToPopulateNextJobs, fetchStatus } from \".\";\nimport { notifyWorkerTab } from \"./tabBridge\";\nlet currentlyFetching = false;\n/**\n * Refresh the queue and load new, unlocked jobs. You need to call this function in your\n * code if you know, there are new jobs added (e.g. \"Scan complete site\" button).\n */\n\nasync function refreshQueue(doFetchStatus = true) {\n  if (currentlyFetching) {\n    // There is still a request, skip this\n    return;\n  } // Check, if the current worker is locked\n\n\n  if (window.realQueueWorker) {\n    currentlyFetching = true;\n\n    try {\n      await createJobToPopulateNextJobs(0)();\n      doFetchStatus && fetchStatus(true);\n    } finally {\n      currentlyFetching = false;\n    }\n  } else {\n    // Let the other tab know that it should refresh the queue\n    notifyWorkerTab({\n      event: \"refreshQueue\"\n    });\n  }\n}\n\nexport { refreshQueue };","import { getStaticOptions, localStorageTest, request } from \"../utils\";\nimport { getGlobalQueue } from \".\";\nimport { locationRestJobsGet } from \"../wp-api\";\nimport { REMAINING_EVENT } from \"../types\";\n\n/**\n * Allows to restore jobs from the local storage. This is helpful especially\n * when the jobs got locked by the server and could not be \"restored the next time\".\n */\nconst LOCAL_STORAGE_KEY_RESTORE_JOBS = \"real-queue-restore-jobs\";\n/**\n * Fetch the next list of jobs so we can populate to our queue.\n */\n\nasync function restoreJobsFromLocalStorage(queueClass = getGlobalQueue().enqueueHandler()) {\n  if (localStorageTest()) {\n    const lsKey = \"\".concat(LOCAL_STORAGE_KEY_RESTORE_JOBS, \"-\").concat(getStaticOptions().localStorageSuffix);\n    const ids = localStorage.getItem(lsKey);\n    localStorage.removeItem(lsKey);\n\n    if (ids) {\n      try {\n        const {\n          jobs,\n          remaining\n        } = await request({\n          location: locationRestJobsGet,\n          params: {\n            ids\n          }\n        });\n        const unfinished = jobs.filter(({\n          process,\n          process_total,\n          runs,\n          retries,\n          locked\n        }) => process < process_total && runs < retries + 1 && !locked);\n        queueClass.enqueueFromList(unfinished);\n        getStaticOptions().remaining = remaining;\n        document.dispatchEvent(new CustomEvent(REMAINING_EVENT, {\n          detail: {\n            remaining\n          }\n        })); // Save back the \"unfinished\" jobs so dangling jobs are automatically removed\n\n        localStorage.setItem(lsKey, unfinished.map(({\n          id\n        }) => id).join(\",\"));\n        return unfinished.length > 0;\n      } catch (e) {// Silence is golden.\n      }\n    }\n  }\n\n  return false;\n}\n\nexport { LOCAL_STORAGE_KEY_RESTORE_JOBS, restoreJobsFromLocalStorage };","import { REMAINING_EVENT } from \"../../types\";\nimport { getStaticOptions, localStorageTest, request } from \"../../utils\";\nimport { locationRestJobExecute } from \"../../wp-api\";\nimport { LOCAL_STORAGE_KEY_RESTORE_JOBS } from \"../restoreFromLocalStorage\";\n/**\n * Execute a server job. This can potentially execute more jobs by IDs to get rid\n * of requests overhead.\n */\n\nasync function executeServerJob(job, tryIds) {\n  var _failedJob$exception, _failedJob$exception$;\n\n  const {\n    id,\n    delay_ms\n  } = job;\n  const result = await request({\n    location: locationRestJobExecute,\n    request: {\n      try: tryIds.join(\",\")\n    },\n    params: {\n      id\n    }\n  }); // TODO: implement `pause`\n\n  const {\n    done,\n    failed,\n    remaining\n  } = result; // Override global state\n\n  getStaticOptions().remaining = remaining;\n  document.dispatchEvent(new CustomEvent(REMAINING_EVENT, {\n    detail: {\n      remaining\n    }\n  })); // Is the passed `job` failed?\n\n  const [failedJob] = failed.filter(({\n    id: failedId\n  }) => failedId === id);\n  const [doneJob] = done.filter(({\n    id: doneId\n  }) => doneId === id);\n\n  if ( // Check if the requested job is completely processed and retry again\n  done.length === 0 && !failedJob || // Check if the requested job needs to be retried cause it failed\n  failedJob && failedJob.runs <= failedJob.retries) {\n    await new Promise(resolve => setTimeout(resolve, delay_ms));\n    return executeServerJob(job, tryIds);\n  } // Is the passed `job` completed?\n\n\n  if ( // Our job is already processed by another worker? Perhaps another tab? Perhaps cronjob? We do not know\n  (failedJob !== null && failedJob !== void 0 && (_failedJob$exception = failedJob.exception) !== null && _failedJob$exception !== void 0 && (_failedJob$exception$ = _failedJob$exception.errors) !== null && _failedJob$exception$ !== void 0 && _failedJob$exception$[\"real_queue_job_locked\"] || doneJob || failedJob && failedJob.runs > failedJob.retries) && localStorageTest()) {\n    var _localStorage$getItem;\n\n    // Remove from our localStorage, as we do not need to restore it no more\n    const lsKey = \"\".concat(LOCAL_STORAGE_KEY_RESTORE_JOBS, \"-\").concat(getStaticOptions().localStorageSuffix);\n    const restorable = ((_localStorage$getItem = localStorage.getItem(lsKey)) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.split(\",\").map(Number)) || [];\n    const idx = restorable.indexOf(id);\n\n    if (idx > -1) {\n      restorable.splice(idx, 1);\n    }\n\n    localStorage.setItem(lsKey, restorable.join(\",\"));\n  }\n\n  return result;\n}\n\nexport { executeServerJob };","import { JOB_DONE_EVENT_PREFIX } from \"../../types\";\nimport { executeServerJob } from \"./executor\";\nimport { jobDelay } from \"..\";\n/**\n * Memorize all executed server jobs to avoid multiple executions.\n * Why: We have created a task for each job, but on server side we\n * are executing jobs iteratively until max execution time exceeded.\n *\n * Simply said: One network request could potentially execute\n * multiple jobs.\n */\n\nconst SUCCESSFUL_SERVER_JOBS = [];\n/**\n * Convert a server job to promise.\n *\n * @param tryIds All the Job IDs which should be also be tried with this single request\n */\n\nfunction convertServerJobToPromise(queue, job, tryIds) {\n  const {\n    id,\n    type\n  } = job;\n\n  const fn = async () => {\n    const dispatchDoneEvent = success => document.dispatchEvent(new CustomEvent(\"\".concat(JOB_DONE_EVENT_PREFIX).concat(type), {\n      detail: {\n        job,\n        success\n      }\n    }));\n\n    if (SUCCESSFUL_SERVER_JOBS.indexOf(id) > -1) {\n      // Job already executed, skip this!\n      dispatchDoneEvent(true);\n      return;\n    }\n\n    try {\n      const {\n        done\n      } = await executeServerJob(job, tryIds);\n      SUCCESSFUL_SERVER_JOBS.push(...done.map(({\n        id\n      }) => id));\n      dispatchDoneEvent(SUCCESSFUL_SERVER_JOBS.indexOf(id) > -1);\n    } catch (e) {\n      // Something went wrong between request and WP REST API - we pause the queue here cause\n      // we wait for the next refresh of the page - the REST API response is always valid and\n      // does not throw any error\n      queue.pause();\n    }\n  };\n\n  const delay = () => SUCCESSFUL_SERVER_JOBS.indexOf(id) > -1 ? Promise.resolve() : jobDelay(job);\n\n  return [fn, delay];\n}\n\nexport { convertServerJobToPromise };","import { getStaticOptions, localStorageTest } from \"../../utils\";\nimport { LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX } from \".\";\n/**\n * Check existing worker notifications and execute a given callback.\n */\n\nfunction checkWorkerNotifications(callbacks) {\n  if (localStorageTest()) {\n    const lsPrefix = \"\".concat(LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX).concat(getStaticOptions().localStorageSuffix);\n\n    for (const lsEntryName of Object.keys(localStorage)) {\n      if (lsEntryName.startsWith(lsPrefix)) {\n        var _callbacks$event;\n\n        const {\n          event,\n          data\n        } = JSON.parse(localStorage.getItem(lsEntryName));\n        localStorage.removeItem(lsEntryName);\n        (_callbacks$event = callbacks[event]) === null || _callbacks$event === void 0 ? void 0 : _callbacks$event.call(callbacks, data);\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexport { checkWorkerNotifications };","import { getStaticOptions, localStorageTest } from \"../../utils\";\nimport { LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX } from \".\";\n/**\n * Clear all worker notifications.\n */\n\nfunction clearWorkerNotifications() {\n  if (localStorageTest()) {\n    const lsPrefix = \"\".concat(LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX).concat(getStaticOptions().localStorageSuffix);\n\n    for (const lsEntryName of Object.keys(localStorage)) {\n      if (lsEntryName.startsWith(lsPrefix)) {\n        localStorage.removeItem(lsEntryName);\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexport { clearWorkerNotifications };","import { getStaticOptions, localStorageTest } from \"../../utils\";\nconst LOCAL_STORAGE_KEY_LOCK_TAB = \"real-queue-lock-tab\";\nlet keepUpToDateInterval;\n/**\n * Lock this tab as \"current runner\". This allows you to run the queue only in one tab.\n *\n * @return `true` when the current tab is locked and should not process any jobs\n */\n\nfunction lockTab(state) {\n  if (localStorageTest()) {\n    const lsKey = \"\".concat(LOCAL_STORAGE_KEY_LOCK_TAB, \"-\").concat(getStaticOptions().localStorageSuffix);\n\n    if (typeof state === \"boolean\") {\n      clearInterval(keepUpToDateInterval);\n    }\n\n    if (state === true) {\n      const fnWrite = () => localStorage.setItem(lsKey, new Date().getTime().toString());\n\n      fnWrite();\n      keepUpToDateInterval = setInterval(fnWrite, 3000);\n    } else if (state === false) {\n      localStorage.removeItem(lsKey);\n    }\n\n    const currentValue = +localStorage.getItem(lsKey);\n\n    if (currentValue === 0 || isNaN(currentValue)) {\n      return false;\n    }\n\n    return new Date().getTime() - currentValue < 7000;\n  }\n\n  return false;\n}\n\nexport { LOCAL_STORAGE_KEY_LOCK_TAB, lockTab };","import { getStaticOptions, localStorageTest } from \"../../utils\";\nconst LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX = \"real-queue-notify-worker-\";\n\n/**\n * Notify worker tab to do something.\n */\nfunction notifyWorkerTab(data) {\n  if (localStorageTest()) {\n    const lsKey = \"\".concat(LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX).concat(getStaticOptions().localStorageSuffix, \"-\").concat(new Date().getTime());\n    localStorage.setItem(lsKey, JSON.stringify(data));\n    return true;\n  }\n\n  return false;\n}\n\nexport { notifyWorkerTab, LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX };","/**\n * You need to append the `type` to the event name, e.g. `RealQueue/ClientJob/example`.\n *\n * This should execute the client job via JavaScript. Keep in mind, that you need to manually\n * update the process via a server request for each item! See also the PHP class\n * `DevOwl\\RealQueue\\queue\\Job#worker` for more information.\n *\n * You are allowed to throw errors, this causes the client job to be retried according to `retries`.\n */\nexport const CLIENT_JOB_EVENT_PREFIX = \"RealQueue/ClientJob/\";","export const JOB_DELAY_EVENT_PREFIX = \"RealQueue/JobDelay/\";","export const JOB_DONE_EVENT_PREFIX = \"RealQueue/JobDone/\";","export const JOBS_DELETED_EVENT = \"RealQueue/JobsDeleted\";","export const JOBS_RETRIED_EVENT = \"RealQueue/JobsRetried\";","export const JOBS_SKIPPED_EVENT = \"RealQueue/JobsSkipped\";","/**\n * This event is dispatched when the queue got updated and remaining counts got changed.\n */\nexport const REMAINING_EVENT = \"RealQueue/Remaining\";","/**\n * This event is dispatched when the queue got a status update.\n * See also `fetchStatus`.\n */\nexport const STATUS_EVENT = \"RealQueue/Status\";","export const STATUS_ADDITIONAL_DATA_EVENT = \"RealQueue/Status/AdditionalData\";","/* istanbul ignore file: this file does not contain any logic, only factory calls */\nimport { createLocalizationFactory } from \"@devowl-wp/utils\"; // Only needed once per `window`\n\nlet FACTORY_MEMO;\n\nfunction get() {\n  return FACTORY_MEMO ? FACTORY_MEMO : FACTORY_MEMO = createLocalizationFactory(\"\".concat(process.env.rootSlug, \"-\").concat(process.env.slug));\n}\n\nconst _n = (...args) => get()._n(...args);\n\nconst _nx = (...args) => get()._nx(...args);\n\nconst _x = (...args) => get()._x(...args);\n\nconst __ = (...args) => get().__(...args);\n\nconst _i = (...args) => get()._i(...args);\n\nexport { _n, _nx, _x, __, _i };","/* istanbul ignore file: this file does not contain any logic, only factory calls */\nimport { BaseOptions } from \"@devowl-wp/utils\";\n\nconst getStaticOptions = () => window[BaseOptions.getPureSlug(process.env.slug, true)].others;\n\nexport { getStaticOptions };\nexport * from \"./request\";\nexport * from \"./i18n\";\nexport * from \"./ready\";\nexport * from \"./localStorageTest\";\nexport * from \"./waitObject\";","let memoizeSupported = undefined;\n/**\n * Checks if localStorage is available. E.g. private modes in browsers\n * does not allow to write to localStorage.\n */\n\nfunction localStorageTest() {\n  if (typeof memoizeSupported === \"boolean\") {\n    return memoizeSupported;\n  }\n\n  const test = \"real-queue-test\";\n\n  try {\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n    memoizeSupported = true;\n    return true;\n  } catch (e) {\n    memoizeSupported = false;\n    return false;\n  }\n}\n\nexport { localStorageTest };","/**\n * Wait DOM is ready depending on a state.\n *\n * - `interactive`: Defer scripts are executing, but DOM is ready\n * - `complete`: All scripts including deferred ones are executed and DOM is ready\n *\n * @see https://stackoverflow.com/a/65430734/5506547\n * @see https://stackoverflow.com/a/51980980/5506547\n */\nconst ready = (fn, state = \"complete\") => {\n  return new Promise(resolve => {\n    if (document.readyState === state) {\n      fn === null || fn === void 0 ? void 0 : fn();\n      resolve();\n    } else {\n      document.addEventListener(\"readystatechange\", () => {\n        if (document.readyState === state) {\n          fn === null || fn === void 0 ? void 0 : fn();\n          resolve();\n        }\n      });\n    }\n  });\n};\n\nexport { ready };","/* istanbul ignore file: this file does not contain any logic, only factory calls */\nimport { createRequestFactory, BaseOptions } from \"@devowl-wp/utils\"; // Only needed once per `window`\n\nlet FACTORY_MEMO;\n\nfunction get() {\n  return FACTORY_MEMO ? FACTORY_MEMO : FACTORY_MEMO = createRequestFactory(window[BaseOptions.getPureSlug(process.env.slug, true)]);\n}\n\nconst urlBuilder = (...args) => get().urlBuilder(...args);\n\nconst request = (...args) => get().request(...args);\n\nexport { urlBuilder, request };","/**\n * Wait for a given object which is calculated through a callback.\n */\nasync function waitObject(getObject, delayNextCheck = 500, maxTries = 0) {\n  let i = 0;\n\n  while (!getObject()) {\n    if (maxTries > 0 && i >= maxTries) {\n      return undefined;\n    }\n\n    await new Promise(r => setTimeout(r, delayNextCheck));\n    i++;\n  }\n\n  return getObject();\n}\n\nexport { waitObject };","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobGet = {\n  path: \"/job/:id\",\n  method: RouteHttpVerb.GET\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobExecute = {\n  path: \"/job/:id\",\n  method: RouteHttpVerb.POST\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobResultPost = {\n  path: \"/job/:id/result\",\n  method: RouteHttpVerb.POST\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobsDelete = {\n  path: \"/jobs\",\n  method: RouteHttpVerb.DELETE\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobsGet = {\n  path: \"/jobs\",\n  method: RouteHttpVerb.GET\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobsRetryPost = {\n  path: \"/jobs/retry\",\n  method: RouteHttpVerb.POST\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestJobsSkipPost = {\n  path: \"/jobs/skip\",\n  method: RouteHttpVerb.POST\n};","import { RouteHttpVerb } from \"@devowl-wp/utils\";\nexport const locationRestStatusGet = {\n  path: \"/status\",\n  method: RouteHttpVerb.GET\n};","module.exports = React;","module.exports = ReactDOM;","module.exports = devowlWp_utils;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t826: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkdevowlWp_realQueue\"] = self[\"webpackChunkdevowlWp_realQueue\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [764], () => (__webpack_require__(3742)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","ErrorModalListItem","item","actions","type","label","description","failedJobs","busy","setBusy","useState","handleDelete","useCallback","async","deleteJobs","handleRetry","retryJobs","handleSkip","skipJobs","useActionText","action","defaultText","_actions$filter$","filter","a","linkText","React","createElement","spinning","style","paddingLeft","paddingRight","key","onClick","overlay","__","map","url","target","window","open","Boolean","danger","title","Fragment","marginTop","slice","job","id","exception","errors","console","log","Object","keys","code","dangerouslySetInnerHTML","__html","join","ErrorModalList","list","size","dataSource","values","renderItem","ErrorModal","useStatusErrors","visible","setVisible","useEffect","activeElement","document","length","test","nodeName","hasAttribute","listener","addEventListener","once","removeEventListener","className","footer","width","closable","Provider","children","prefixCls","useProgress","fetchStatusInterval","fetchAdditionalData","onAdditionalData","onCancel","cancelling","setCancelling","jobsStarted","setJobsStarted","remaining","setRemaining","percent","setPercent","total","setTotal","failure","setFailure","paused","setPaused","currentJob","setCurrentJob","status","detail","currentJobs","remainingArr","additionalData","toFixed","undefined","settings","push","applyCancelState","listenerDeleted","params","deletedType","handleCancel","fetchStatus","setPreviousHash","setErrors","applyErrors","hash","previousHash","errorModalElement","body","appendChild","render","realQueueWorker","setInterval","refreshQueue","visibilityState","concat","resolve","fetchJob","saveJobResult","process_total","Promise","setTimeout","WINDOW_ACTIVITY_DETECTOR_IS_ACTIVE_KEY","createActivityDetector","activityDetector","autoInit","on","init","convertClientJobToPromise","queue","success","dispatchEvent","CustomEvent","updateRemaining","e","pause","executeClientJob","run","result","retries","reject","_localStorage$getItem","lsKey","localStorageSuffix","restorable","localStorage","getItem","split","Number","idx","indexOf","splice","setItem","timeout","currentlyFetching","intervalOrImmediate","immediate","fn","location","clearInterval","getGlobalQueue","realQueueInstance","autoStart","concurrency","queueClass","enqueueHandler","this","_queue","setHandler","jobDelay","isIdle","delay_ms","response","lock","createJobToPopulateNextJobs","afterJobId","jobs","after","enqueueFromList","handler","request","process","errorCode","message","errorMessage","data","errorData","JSON","stringify","pauseToAvoidRecurringException","listenerRetried","retriedType","skippedType","RealQueueClass","constructor","alreadyAddedJobIds","_handler","listenRetries","listenDeletions","tryJobIds","worker","runs","listenerFailedEvent","listenerFailed","doneJobId","alreadyIdx","previousAt","previousJob","forEach","addAll","enqueue","options","Error","element","dequeue","shift","filterQueueItem","removeByType","forgetAboutAlreadyAdded","removedIds","doFetchStatus","event","LOCAL_STORAGE_KEY_RESTORE_JOBS","restoreJobsFromLocalStorage","ids","removeItem","unfinished","locked","executeServerJob","tryIds","_failedJob$exception","_failedJob$exception$","try","done","failed","failedJob","failedId","doneJob","doneId","SUCCESSFUL_SERVER_JOBS","convertServerJobToPromise","dispatchDoneEvent","checkWorkerNotifications","callbacks","lsPrefix","lsEntryName","startsWith","_callbacks$event","parse","call","clearWorkerNotifications","LOCAL_STORAGE_KEY_LOCK_TAB","keepUpToDateInterval","lockTab","state","fnWrite","Date","getTime","toString","currentValue","isNaN","LOCAL_STORAGE_KEY_QUEUE_NOTIFY_WORKER_PREFIX","notifyWorkerTab","CLIENT_JOB_EVENT_PREFIX","JOB_DELAY_EVENT_PREFIX","JOB_DONE_EVENT_PREFIX","JOBS_DELETED_EVENT","JOBS_RETRIED_EVENT","JOBS_SKIPPED_EVENT","REMAINING_EVENT","STATUS_EVENT","STATUS_ADDITIONAL_DATA_EVENT","FACTORY_MEMO","get","createLocalizationFactory","_n","args","_nx","_x","_i","getStaticOptions","BaseOptions","others","memoizeSupported","localStorageTest","ready","readyState","createRequestFactory","urlBuilder","waitObject","getObject","delayNextCheck","maxTries","i","r","locationRestJobGet","path","method","RouteHttpVerb","locationRestJobExecute","locationRestJobResultPost","locationRestJobsDelete","locationRestJobsGet","locationRestJobsRetryPost","locationRestJobsSkipPost","locationRestStatusGet","module","exports","ReactDOM","devowlWp_utils","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","O","chunkIds","priority","notFulfilled","Infinity","fulfilled","j","every","n","getter","__esModule","d","definition","o","defineProperty","enumerable","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}